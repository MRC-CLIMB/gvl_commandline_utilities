
"""
Given a Galaxy tools directory, look for env.sh files and use the directory 
structure and the PATH settings to build module files. These env.sh files are 
usually created by the Galaxy Toolshed.
Any old module files with a whatis string indicating they were created by this 
script will be removed before creating the new files, so that tools deleted from 
the Toolshed will be cleaned up.
"""

##
# Clare Sloggett, VLSCI, University of Melbourne
# Authored as part of the Genomics Virtual Laboratory project
##

import re
import os
import argparse
import sys
from collections import defaultdict

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('--tools_dir', default='/mnt/galaxy/tools', help='directory in which Galaxy Toolshed tools are installed')
parser.add_argument('--modules_dir', default=None, help='destination directory in which to create module files') 
parser.add_argument('--force', action='store_true', help="do not ask for confirmation before deleting old files.")                                                                             
args = parser.parse_args()

if args.modules_dir is None:
    modules_home = os.environ.get('MODULESHOME')
    if modules_home is None:
        raise Exception("Environment variable $MODULESHOME does not appear to be set; Modules may not be installed. If it is you may need to specify the destination directory manually using --modules_dir.")
    args.modules_dir = os.path.join(modules_home, 'modulefiles')

def get_tool_version(dir_string):
    """
    Strip off tools_dir and take the first two names in the directory hierarchy to
    be the tool name and version. Return (tool, version).
    """
    match = re.match('{0}/(.+)'.format(args.tools_dir), os.path.normpath(dir_string))
    if not match:
        raise Exception("Could not parse env.sh path: " + dir_string + "\n")
    directories = match.group(1).split('/')  #note normpath removes trailing '/'
    if len(directories) < 2:
        raise Exception("Module name does not appear to have a version: " + match.group(1) + "\n")
    tool, version = directories[:2]
    return (tool, version)

# Delete any old module files, i.e. which contain the expected whatis regex
# First build a list and warn the user
delete_list = []
delete_regex = re.compile("^module-whatis\s+Module automatically generated by GVL scripts")
for (dir, subdirs, files) in os.walk(args.modules_dir):
    for file in files:
        filepath = os.path.join(dir,file)
        for line in open(filepath,'rb'):
            if delete_regex.search(line):
                # We matched the regex; delete this file
                delete_list.append(filepath)
                break
if len(delete_list) > 0:
    print "The following old module files will be deleted before creating new ones:"
    print "\n".join(delete_list)
    if not args.force:
        print "Ok? [y/N]"
        if raw_input().lower() != 'y':
            sys.exit()
        print "Deleting old module files"
        for file in delete_list:
            os.remove(file)

# For each tool version, find all relevant env.sh files
tool_shells = defaultdict(list)
for (dir, subdirs, files) in os.walk(args.tools_dir):
    for file in files:
        if file=='env.sh':
            tool, version = get_tool_version(dir)
            tool_shells[(tool, version)].append(dir)

# Parse out paths and add to module files
for ((tool_name, tool_version), dirs) in tool_shells.iteritems():
    path_additions = []
    for dir in dirs:
        env_path = os.path.join(dir, 'env.sh')
        with open(env_path) as f:
            for row in f:
                # Get anything after PATH=, stopping if we see whitespace or semicolon
                # TODO: need to also capture other environment variables, e.g. PYTHONPATH
                # TODO: we're missing the case where we append one environment variable to another
                envmatch = re.search('PATH=(.+?)(\s|\Z|\;)', row)
                if envmatch:
                    paths = envmatch.group(1).split(':')
                    for path in paths:
                        if len(path) > 0 and path[0] != '$':
                            path_additions.append(path)
    module_contents = "#%Module\n"
    module_contents += "# Built automatically from Galaxy env.sh tool setup files\n\n"
    module_contents += "".join(["append-path  PATH  "+path+"\n" for path in path_additions])
    module_contents += "module-whatis  Module automatically generated by GVL scripts, for tool {0}, version {1}. Paths sourced from Galaxy env.sh tool setup files.\n".format(tool_name, tool_version)

    # Write out the module file
    module_tool_path = os.path.join(args.modules_dir, tool_name)
    if not os.path.exists(module_tool_path):
        os.makedirs(module_tool_path)

    module_full_path = os.path.join(module_tool_path, tool_version)

    print "Writing module to",module_full_path

    f = open(module_full_path, 'wb')
    f.write(module_contents)
    f.close()

#TODO it would be nice to grab some extra module-whatis information from the xml files



